# July 29, 2025 - Daily Drill

## üéØ Daily Goals

- [x] Review Anki Deck
- [x] Lumosity training
- [x] Leetcode
- [x] Developing laplace
- [x] Langchain Learning

## üìù What I learned:

### [ryos](https://os.ryo.lu/)

<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; margin: 1.5rem 0;">
    <iframe src="https://www.youtube.com/embed/TQhv6Wol6Ns" 
            style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none;" 
            allowfullscreen>
    </iframe>
</div>

#### Reflection

This is an interesting web project built by Ryo Lu, Cursor's Head of Design. He designed a web page to mimic old macintosh os. It has a web broswer that allows you to see different websites in different times even in the future. The future ones are AI generated in real time with careful prompt template and style specification. There are all sorts of other "softwares" available on the website that allows you to play with. Like a video camera with 
weird shaders, a video player that stores all ryo's favorite old clips, and a regular minesweeper. A lots of the code is actually written using AI. Two things that Ryo said left a particularly deep impression on me. One is how important it is to just play around with the technology to understand it fully. No matter it is learning web development or AI or vide coding. Just start with a project that interests you and get your hands dirty. Another things is about vibe coding. With AI, we can actually implement so many our ideas just with a few prompts. Some people just think of vibe coding as putting in their crazy idea in the chat window and expects it to work perfectly. It usually doesn't work like that. You need to have the ability to decompose bigger promblems into smaller ones. Understand how your architecture is gonna belike. Provide the correct context and prompt to the AI and then you might get what you want at the first place. 

### [211. Design Add and Search Words Data Structure](https://leetcode.com/problems/design-add-and-search-words-data-structure/description/)

#### Thinking Process

At first glance, I think of a brute force solution where we just add every word into a set and during the search we just generate all possible strings and check if that is valid. The brute force is a bit tricky since we need to flatten the nested for loop to generate all possible combinations. My implementation is to first check for how many wild card there is. And loop from 0 to 2^k^ - 1 where k equals to the number of wildcard symbol. Then we map the integer to list of character. The way to think of the number is to convert it into a base-26 number. Then we can map each digit into a character. Anyways, the better way is to use Trie. That way we can prune the search tree early. Since if we don't have certain prefix of the string, we can call for a stop immediately.

#### Complexity Analysis

Assume we have `n` elements already in the set. And the word for insertion and search has length `l`

*Brutal Force* 

- **Time Complexity: O(log(n)) for add word; O(26^l^log(n)) for word search**
- **Space Complexity: O(n)**

*Trie*

- **Time Complexity: O(l) for add word; O(26^l^) for word search**
- **Space Complexity: O(n)**

For word search, it would usually end within O(l). In the worst case, we need to search for all the nodes. Say we got a input string like "..z" , and we have all permuatations of the three-character word except for the ones end with z. Then we need to check every single node in the tree. Thus, O(26^l^)

#### Key Takeaways

- Use trie for word search can help with search tree pruning
- Use mapping to flatten nested for loops 

## üöÄ Resources that Requires Further Study

- [awesome cursor rules](https://github.com/PatrickJS/awesome-cursorrules)
- [jwt](https://auth0.com/docs/secure/tokens/json-web-tokens)
- [leetcode company wise](https://github.com/liquidslr/leetcode-company-wise-problems)

